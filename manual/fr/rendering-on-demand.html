<!DOCTYPE html><html lang="fr"><head>
    <meta charset="utf-8">
    <title>Rendering on Demand</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@threejs">
    <meta name="twitter:title" content="Three.js ‚Äì Rendering on Demand">
    <meta property="og:image" content="https://threejs.org/files/share.png">
    <link rel="shortcut icon" href="/files/favicon_white.ico" media="(prefers-color-scheme: dark)">
    <link rel="shortcut icon" href="/files/favicon.ico" media="(prefers-color-scheme: light)">

    <link rel="stylesheet" href="/manual/resources/lesson.css">
    <link rel="stylesheet" href="/manual/resources/lang.css">
<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="importmap">
{
  "imports": {
    "three": "../../build/three.module.js"
  }
}
</script>
  </head>
  <body>
    <div class="container">
      <div class="lesson-title">
        <h1>Rendu √† la demande</h1>
      </div>
      <div class="lesson">
        <div class="lesson-main">
          <!-- <p>D√©sol√©, cet article n'a pas encore √©t√© traduit. <a href="https://github.com/mrdoob/three.js">Les traductions sont le bienvenue</a>! üòÑ</p>
<p><a href="/manual/en/rendering-on-demand.html">Voici l'article anglais originel pour le moment</a>.</p> -->
        <p>Ce sujet peut para√Ætre √©vident pour certains, mais au cas o√π... la plupart des exemples Three.js sont rendus en continu. Autrement-dit, ils mettent en place une boucle
          <code class="notranslate" translate="no">requestAnimationFrame</code> ou "<em>rAF loop</em>" qui ressemble √† √ßa:</p>
          <pre class="prettyprint showlinemods notranslate lang-js" translate="no">function render() {
            ...
            requestAnimationFrame(render);
          }
          requestAnimationFrame(render);
          </pre>
          <p>Pour quelque chose qui s'anime, c'est plut√¥t cens√©. Mais qu'en est-il de quelque chose qui ne s'anime pas ? Dans ce cas, rendre en continu est une perte de puissance pour les appareils, et pour les utilisateurs de terminaux portables, c'est une perte de batterie. </p>
          <p>La fa√ßon la plus √©vidente de r√©soudre ce probl√®me estrendre une fois au d√©but, pour ensuite rendre √† nouveau uniquement lors d'un changement. Les changements inculent les textures ou les mod√®les qui chargent enfin, des donn√©es arrivant de certaines sources ext√©rieures, l'utilisateur qui ajuste les param√®tres ou la cam√©ra, ou qui envoie une entr√©e pertinente.</p>
          <p>Prenons un exemple sur <a href="responsive.html">l'article de Design r√©actif</a>(responsive), et modifions le pour rendre √† la demande.</p>
          <p>D'abord ajoutons les <a href="/docs/#examples/controls/OrbitControls"><code class="notranslate" translate="no">OrbitControls</code></a>, pour qu'il y ait quelque chose de modifiable, que nous pourrons rendre ensuite.</p>
          <pre class="prettyprint showlinemods notranslate lang-js" translate="no">import * as THREE from '/build/three.module.js';
          +import {OrbitControls} from '/examples/jsm/controls/OrbitControls.js';
          </pre>
          <p>et on r√®gle le tout</p>
          <pre class="prettyprint showlinemods notranslate lang-js" translate="no">const fov = 75;
          const aspect = 2;  // the canvas default
          const near = 0.1;
          const far = 5;
          const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
          camera.position.z = 2;
          
          +const controls = new OrbitControls(camera, canvas);
          +controls.target.set(0, 0, 0);
          +controls.update();
          </pre>
          <p>Puisque nous n'allons plus animer les cubes, plus besoin d'en garder la trace</p>
          <pre class="prettyprint showlinemods notranslate lang-js" translate="no">-const cubes = [
            -  makeInstance(geometry, 0x44aa88,  0),
            -  makeInstance(geometry, 0x8844aa, -2),
            -  makeInstance(geometry, 0xaa8844,  2),
            -];
            +makeInstance(geometry, 0x44aa88,  0);
            +makeInstance(geometry, 0x8844aa, -2);
            +makeInstance(geometry, 0xaa8844,  2);
          </pre>
          <p>On peut enlever le code d'animation des cubes et appeler <code class="notranslate" translate="no">requestAnimationFrame</code></p>
          <pre class="prettyprint showlinemods notranslate lang-js" translate="no">-function render(time) {
            -  time *= 0.001;
            +function render() {
            
              if (resizeRendererToDisplaySize(renderer)) {
                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
              }
            
            -  cubes.forEach((cube, ndx) =&gt; {
            -    const speed = 1 + ndx * .1;
            -    const rot = time * speed;
            -    cube.rotation.x = rot;
            -    cube.rotation.y = rot;
            -  });
            
              renderer.render(scene, camera);
            
            -  requestAnimationFrame(render);
            }
            
            -requestAnimationFrame(render);
          </pre>
          <p>ensuite on fait le rendu une fois</p>
          <pre class="prettyprint showlinemods notranslate lang-js" translate="no">render();
          </pre>
          <p>Nous avons besoin de rendre √† chaque fois que <a href="/docs/#examples/controls/OrbitControls"><code class="notranslate" translate="no">OrbitControls</code></a> change les param√®tres de cam√©ra.
          Par chance, <a href="/docs/#examples/controls/OrbitControls"><code class="notranslate" translate="no">OrbitControls</code></a> ex√©cute un √©v√®nement <code class="notranslate" translate="no">change</code> √† chaque fois qu'une modification survient.</p>
          <pre class="prettyprint showlinemods notranslate lang-js" translate="no">controls.addEventListener('change', render);
          </pre>
          <p>Nous devons maintenant nous occuper du cas o√π l'utilisateur change la taille de sa fen√™tre. C'√©tait avant pris en charge automatiquement puisque le rendu √©tait continu, mais maintenant que nous ne le faisons plus, il faut rendre √† nouveau la fen√™tre √† chaque redimensionnement</p>
          <pre class="prettyprint showlinemods notranslate lang-js" translate="no">window.addEventListener('resize', render);
          </pre>
          <p>Avec √ßa, on obtient quelque chose qui se rend √† la demande.</p>
          <p></p<div translate="no" class="threejs_example_container notranslate">
          <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/render-on-demand.html"></iframe></div>
          <a class="threejs_center" href="/manual/examples/render-on-demand.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
          </div>

          <p></p>
          <p><a href="/docs/#examples/controls/OrbitControls"><code class="notranslate" translate="no">OrbitControls</code></a> a des options pour ajouter une sorte d'inertie afin qu'ils semblent moins "rigides" dans leur mouvement. On peut l'activer mettant la propri√©t√© <code class="notranslate" translate="no">enableDamping</code> sur "true".</p>
          <pre class="prettyprint showlinemods notranslate lang-js" translate="no">controls.enableDamping = true;
          </pre>
          <p>Avec <code class="notranslate" translate="no">enableDamping</code> activ√©, on a besoin de <code class="notranslate" translate="no">controls.update</code> dans notre fonction de rendu
            pour que <a href="/docs/#examples/controls/OrbitControls"><code class="notranslate" translate="no">OrbitControls</code></a> continue de nous donner les nouveaux param√®tres de cam√©ras lors du lissage du mouvement. Mais cela veut dire que nos ne pouvons pas appeler <code class="notranslate" translate="no">render</code> directement depuis l'√©v√®nement <code class="notranslate" translate="no">change</code> parce qu'on finirait alors avec une boucle infinie. Les "controls" nous enverraient un √©v√®nement <code class="notranslate" translate="no">change</code> et appelleraient <code class="notranslate" translate="no">render</code>, <code class="notranslate" translate="no">render</code> appellerait <code class="notranslate" translate="no">controls.update</code>, 
            <code class="notranslate" translate="no">controls.update</code> renverrait un nouvel √©v√®nement <code class="notranslate" translate="no">change</code>.</p>
            <p>On peut r√©parer √ßa avec <code class="notranslate" translate="no">requestAnimationFrame</code> pour appeler <code class="notranslate" translate="no">render</code>, mais il faut √™tre s√ªr que nous ne demandons une nouvelle image que si aucune n'a d√©j√† √©t√© demand√©e, ce qu'il est possible de faire en gardant une variable qui v√©rifie si nous l'avons d√©j√† fait.</p>
            <pre class="prettyprint showlinemods notranslate lang-js" translate="no">+let renderRequested = false;

              function render() {
              +  renderRequested = false;
              
                if (resizeRendererToDisplaySize(renderer)) {
                  const canvas = renderer.domElement;
                  camera.aspect = canvas.clientWidth / canvas.clientHeight;
                  camera.updateProjectionMatrix();
                }
              
                renderer.render(scene, camera);
              }
              render();
              
              +function requestRenderIfNotRequested() {
              +  if (!renderRequested) {
              +    renderRequested = true;
              +    requestAnimationFrame(render);
              +  }
              +}
              
              -controls.addEventListener('change', render);
              +controls.addEventListener('change', requestRenderIfNotRequested);
            </pre>
            <p>On devrait √©galement utiliser <code class="notranslate" translate="no">requestRenderIfNotRequested</code> pour le redimensionnment:</p>
            <pre class="prettyprint showlinemods notranslate lang-js" translate="no">-window.addEventListener('resize', render);
              +window.addEventListener('resize', requestRenderIfNotRequested);
            </pre>
            <p>Au remier abord, il est compliqu√© de voir la diff√©rence. Testez l'exemple du dessous, en utilisant les touches directionnelles pour bouger, ou en faisant glisser avec la souris. Puis essayez la m√™me chose sur l'exemple du dessus. Vous devriez voir la diff√©rence. Au dessus, le rendu se stoppe net lorsque l'on bouge dedans, en dessous le rednu est plus "intertiel"</p>


          


        </div>
      </div>
    </div>
  
  <script src="/manual/resources/prettify.js"></script>
  <script src="/manual/resources/lesson.js"></script>




</body></html>