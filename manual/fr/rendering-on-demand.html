<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="utf-8">
  <title>Rendering on Demand</title>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@threejs">
  <meta name="twitter:title" content="Three.js ‚Äì Rendering on Demand">
  <meta property="og:image" content="https://threejs.org/files/share.png">
  <link rel="shortcut icon" href="/files/favicon_white.ico" media="(prefers-color-scheme: dark)">
  <link rel="shortcut icon" href="/files/favicon.ico" media="(prefers-color-scheme: light)">

  <link rel="stylesheet" href="/manual/resources/lesson.css">
  <link rel="stylesheet" href="/manual/resources/lang.css">
  <!-- Import maps polyfill -->
  <!-- Remove this when import maps will be widely supported -->
  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

  <script type="importmap">
{
  "imports": {
    "three": "../../build/three.module.js"
  }
}
</script>
</head>

<body>
  <div class="container">
    <div class="lesson-title">
      <h1>Rendu √† la demande</h1>
    </div>
    <div class="lesson">
      <div class="lesson-main">
        <!-- These comments can be suppressed after pull request is accepted -->
        <!-- <p>D√©sol√©, cet article n'a pas encore √©t√© traduit. <a href="https://github.com/mrdoob/three.js">Les traductions sont le bienvenue</a>! üòÑ</p>
<p><a href="/manual/en/rendering-on-demand.html">Voici l'article anglais originel pour le moment</a>.</p> -->
        <p>L'id√©e peut para√Ætre √©vidente pour certains, mais au juste cas o√π... la plupart des exemples Three.js sont
          rendus en continu. Autrement-dit, ils mettent en place une boucle
          <code class="notranslate" translate="no">requestAnimationFrame</code> ou "<em>rAF loop</em>" qui ressemble √†
          √ßa:
        </p>
        <pre class="prettyprint showlinemods notranslate lang-js" translate="no">function render() {
            ...
            requestAnimationFrame(render);
          }
          requestAnimationFrame(render);
          </pre>
        <p>Pour quelque chose qui s'anime, c'est plut√¥t cens√©. Mais qu'en est-il de quelque chose qui ne s'anime pas ?
          Dans ce cas, rendre en continu est une perte de puissance pour les appareils, mais √©galement une perte de
          batterie pour les utilisateurs de
          terminaux portables. </p>
        <p>La fa√ßon la plus √©vidente de r√©soudre ce probl√®me est de rendre une fois au d√©but, pour ensuite rendre √†
          nouveau
          uniquement lors d'un changement. Les changements inculent les textures ou les mod√®les qui chargent enfin, des
          donn√©es arrivant de certaines sources ext√©rieures, l'utilisateur qui ajuste les param√®tres ou la cam√©ra, ou
          qui envoie une entr√©e pertinente.</p>
        <p>Prenons un exemple sur l'<a href="responsive.html">article de Design r√©actif</a>(responsive), et modifions le
          pour rendre √† la demande.</p>
        <p>D'abord ajoutons les <a href="/docs/#examples/controls/OrbitControls"><code class="notranslate"
              translate="no">OrbitControls</code></a>, pour qu'il y ait quelque chose de modifiable, que nous pourrons
          rendre ensuite.</p>
        <pre class="prettyprint showlinemods notranslate lang-js" translate="no">import * as THREE from '/build/three.module.js';
          +import {OrbitControls} from '/examples/jsm/controls/OrbitControls.js';
          </pre>
        <p>et on r√®gle le tout</p>
        <pre class="prettyprint showlinemods notranslate lang-js" translate="no">const fov = 75;
          const aspect = 2;  // the canvas default
          const near = 0.1;
          const far = 5;
          const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
          camera.position.z = 2;
          
          +const controls = new OrbitControls(camera, canvas);
          +controls.target.set(0, 0, 0);
          +controls.update();
          </pre>
        <p>Puisque nous n'allons plus animer les cubes, plus besoin de les suivre</p>
        <pre class="prettyprint showlinemods notranslate lang-js" translate="no">-const cubes = [
            -  makeInstance(geometry, 0x44aa88,  0),
            -  makeInstance(geometry, 0x8844aa, -2),
            -  makeInstance(geometry, 0xaa8844,  2),
            -];
            +makeInstance(geometry, 0x44aa88,  0);
            +makeInstance(geometry, 0x8844aa, -2);
            +makeInstance(geometry, 0xaa8844,  2);
          </pre>
        <p>On peut enlever le code d'animation des cubes et appeler <code class="notranslate"
            translate="no">requestAnimationFrame</code></p>
        <pre class="prettyprint showlinemods notranslate lang-js" translate="no">-function render(time) {
            -  time *= 0.001;
            +function render() {
            
              if (resizeRendererToDisplaySize(renderer)) {
                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
              }
            
            -  cubes.forEach((cube, ndx) =&gt; {
            -    const speed = 1 + ndx * .1;
            -    const rot = time * speed;
            -    cube.rotation.x = rot;
            -    cube.rotation.y = rot;
            -  });
            
              renderer.render(scene, camera);
            
            -  requestAnimationFrame(render);
            }
            
            -requestAnimationFrame(render);
          </pre>
        <p>ensuite on fait le rendu une fois</p>
        <pre class="prettyprint showlinemods notranslate lang-js" translate="no">render();
          </pre>
        <p>Nous avons besoin de rendre √† chaque fois que <a href="/docs/#examples/controls/OrbitControls"><code
              class="notranslate" translate="no">OrbitControls</code></a> change les param√®tres de cam√©ra.
          Par chance, <a href="/docs/#examples/controls/OrbitControls"><code class="notranslate"
              translate="no">OrbitControls</code></a> ex√©cute un √©v√®nement <code class="notranslate"
            translate="no">change</code> √† chaque fois qu'une modification survient.</p>
        <pre class="prettyprint showlinemods notranslate lang-js" translate="no">controls.addEventListener('change', render);
          </pre>
        <p>Nous devons maintenant nous occuper du cas o√π l'utilisateur change la taille de sa fen√™tre. C'√©tait avant
          pris en charge automatiquement puisque le rendu √©tait continu, mais maintenant que nous ne le faisons plus, il
          faut rendre √† nouveau la fen√™tre √† chaque redimensionnement</p>
        <pre class="prettyprint showlinemods notranslate lang-js" translate="no">window.addEventListener('resize', render);
          </pre>
        <p>Avec √ßa, on obtient quelque chose qui se rend √† la demande.</p>
        <p>
          </p<div translate="no" class="threejs_example_container notranslate">
        <div><iframe class="threejs_example notranslate" translate="no" style=" "
            src="/manual/examples/resources/editor.html?url=/manual/examples/render-on-demand.html"></iframe></div>
        <a class="threejs_center" href="/manual/examples/render-on-demand.html" target="_blank">cliquez ici pour ouvrir
          dans une fen√™tre s√©par√©e</a>
      </div>

      <p></p>
      <p><a href="/docs/#examples/controls/OrbitControls"><code class="notranslate"
            translate="no">OrbitControls</code></a> a des options pour ajouter une sorte d'inertie afin les cubes
        semblent
        moins "rigides" dans leur mouvement. On peut l'activer en mettant la propri√©t√© <code class="notranslate"
          translate="no">enableDamping</code> sur "true".</p>
      <pre class="prettyprint showlinemods notranslate lang-js" translate="no">controls.enableDamping = true;
          </pre>
      <p>Avec <code class="notranslate" translate="no">enableDamping</code> activ√©, on a besoin de <code
          class="notranslate" translate="no">controls.update</code> dans notre fonction de rendu
        pour que <a href="/docs/#examples/controls/OrbitControls"><code class="notranslate"
            translate="no">OrbitControls</code></a> continue de nous donner les nouveaux param√®tres de cam√©ras lors du
        lissage du mouvement. Mais cela veut dire que nos ne pouvons pas appeler <code class="notranslate"
          translate="no">render</code> directement depuis l'√©v√®nement <code class="notranslate"
          translate="no">change</code> parce qu'on finirait alors avec une boucle infinie. Les "controls" nous
        enverraient un √©v√®nement <code class="notranslate" translate="no">change</code> et appelleraient <code
          class="notranslate" translate="no">render</code>, <code class="notranslate" translate="no">render</code>
        appellerait <code class="notranslate" translate="no">controls.update</code>,
        <code class="notranslate" translate="no">controls.update</code> renverrait un nouvel √©v√®nement <code
          class="notranslate" translate="no">change</code>.
      </p>
      <p>On peut r√©parer √ßa avec <code class="notranslate" translate="no">requestAnimationFrame</code> pour appeler
        <code class="notranslate" translate="no">render</code>, mais il faut √™tre s√ªr que nous ne demandons une nouvelle
        image que si aucune n'a d√©j√† √©t√© demand√©e, ce qu'il est possible de faire en gardant une variable qui v√©rifie si
        nous l'avons d√©j√† fait.
      </p>
      <pre class="prettyprint showlinemods notranslate lang-js" translate="no">+let renderRequested = false;

              function render() {
              +  renderRequested = false;
              
                if (resizeRendererToDisplaySize(renderer)) {
                  const canvas = renderer.domElement;
                  camera.aspect = canvas.clientWidth / canvas.clientHeight;
                  camera.updateProjectionMatrix();
                }
              
                renderer.render(scene, camera);
              }
              render();
              
              +function requestRenderIfNotRequested() {
              +  if (!renderRequested) {
              +    renderRequested = true;
              +    requestAnimationFrame(render);
              +  }
              +}
              
              -controls.addEventListener('change', render);
              +controls.addEventListener('change', requestRenderIfNotRequested);
            </pre>
      <p>On devrait √©galement utiliser <code class="notranslate" translate="no">requestRenderIfNotRequested</code> pour
        le redimensionnment:</p>
      <pre class="prettyprint showlinemods notranslate lang-js" translate="no">-window.addEventListener('resize', render);
              +window.addEventListener('resize', requestRenderIfNotRequested);
            </pre>
      <p>Au remier abord, il est compliqu√© de voir la diff√©rence. Testez l'exemple du dessous, en utilisant les touches
        directionnelles pour bouger, ou en faisant glisser avec la souris. Puis essayez la m√™me chose sur l'exemple du
        dessus. Vous devriez voir la diff√©rence. Au dessus, le rendu se stoppe net lorsque l'on bouge dedans, en dessous
        le rendnu est plus "intertiel".</p>
      <p></p>
      <div translate="no" class="threejs_example_container notranslate">
        <div><iframe class="threejs_example notranslate" translate="no" style=" "
            src="/manual/examples/resources/editor.html?url=/manual/examples/render-on-demand-w-damping.html"></iframe>
        </div>
        <a class="threejs_center" href="/manual/examples/render-on-demand-w-damping.html" target="_blank">cliquez ici
          pour ouvrir dans une nouvelle fen√™tre</a>
      </div>

      <p></p>
      <p>On va maintenant cr√©er une interface graphique "lil-gui", et faire en sorte que les changements se rendent √† la
        demande.</p>
      <pre class="prettyprint showlinemods notranslate lang-js" translate="no">import * as THREE from '/build/three.module.js';
              import {OrbitControls} from '/examples/jsm/controls/OrbitControls.js';
              +import {GUI} from '/examples/jsm/libs/lil-gui.module.min.js';
            </pre>
      <p>On pourra changer les param√®tres de couleur et d'√©chelle sur x, pour chaque cube. Pour modifier la couleur, on
        utilise le <code class="notranslate" translate="no">ColorGUIHelper</code> qu'on a d√©j√† cr√©√© dans l'<a
          href="lights.html">article sur les lumi√®res</a>.</p>
      <p>Tout d'abord, on doit cr√©er notre interface graphique (GUI)</p>
      <pre class="prettyprint showlinemods notranslate lang-js" translate="no">const gui = new GUI();
            </pre>
      <p>puis pour chaque cube, on cr√©e un dossier et on ajoute deux "controls", un pour
        <code class="notranslate" translate="no">material.color</code> et un second pour <code class="notranslate"
          translate="no">cube.scale.x</code>.
      </p>
      <pre class="prettyprint showlinemods notranslate lang-js" translate="no">function makeInstance(geometry, color, x) {
              const material = new THREE.MeshPhongMaterial({color});
            
              const cube = new THREE.Mesh(geometry, material);
              scene.add(cube);
            
              cube.position.x = x;
            
            +  const folder = gui.addFolder(`Cube${x}`);
            +  folder.addColor(new ColorGUIHelper(material, 'color'), 'value')
            +      .name('color')
            +      .onChange(requestRenderIfNotRequested);
            +  folder.add(cube.scale, 'x', .1, 1.5)
            +      .name('scale x')
            +      .onChange(requestRenderIfNotRequested);
            +  folder.open();
            
              return cube;
            }
            </pre>
      <p>Vous pouvez voir juste au dessus que les contr√¥les de "lil-gui" ont une m√©thode <code class="notranslate"
          translate="no">onChange</code> √† laquelle on peut passer un callback pour √™tre appel√©e quand la GUI change une
        valeur. Dans notre cas, on a juste besoin d'appeler <code class="notranslate"
          translate="no">requestRenderIfNotRequested</code>. L'appel de <code class="notranslate"
          translate="no">folder.open</code> ouvre les fichers d√®s l'ex√©cution du code.</p>
      <p></p>
      <div translate="no" class="threejs_example_container notranslate">
        <div><iframe class="threejs_example notranslate" translate="no" style=" "
            src="/manual/examples/resources/editor.html?url=/manual/examples/render-on-demand-w-gui.html"></iframe>
        </div>
        <a class="threejs_center" href="/manual/examples/render-on-demand-w-gui.html" target="_blank">cliquez ici pour
          ouvrir dans une nouvelle fen√™tre</a>
      </div>

      <p></p>
      <p>J'esp√®re que tout √ßa vous donne un bon aper√ßu de la fa√ßon de faire rendre three.js √† la demande, au lieu de
        rendre en continu. Les appli/pages qui rendent three.js √† la demande ne sont pas si courantes, puisque la
        plupart des pages ustilisant three.js sont soit des jeux, soit des animations 3D; mais les pages qui
        pourraient mieux se rendre √† la demande seraient par exemple un visualiseur de cartes, un editeur 3D, un
        g√©n√©rateur de
        graphiques 3D, un ctalogue de produits, etc...</p>


    </div>
  </div>
  </div>

  <script src="/manual/resources/prettify.js"></script>
  <script src="/manual/resources/lesson.js"></script>




</body>

</html>